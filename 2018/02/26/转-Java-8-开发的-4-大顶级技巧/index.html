<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="KIWI,kiwiflydream@gmail.com"><meta name="referrer" content="no-referrer"><title>[转] Java 8 开发的 4 大顶级技巧 · 求索之路</title><meta name="description" content="本文由 简悦 SimpRead 转码， 原文地址 http://www.importnew.com/22417.html 译文出处： Elyn   原文出处：Java 8 Top Tips

我使用 Java 8 编码已经有些年头，既用于新的应用程序，也用来迁移现有的应用，感觉是时候写一些我发现的非"><meta name="keywords" content="Hexo,HTML,CSS,java,Linux,code,spring"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><link rel="stylesheet" href="/css/prism-ghcolors.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title><a href="/">求索之路</a></h3><div class="description"><p>路漫漫其修远兮，吾将上下而求索</p></div></div></div><ul class="social-links"><li><a href="http://weibo.com/1761079264"><i class="fa fa-weibo"></i></a></li><li><a href="http://github.com/kiwiflydream"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">Home</a></li><li><a href="/about">Sobre</a></li><li><a href="/archives">Arquivo</a></li><li><a href="/links">Links</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="https://avatars2.githubusercontent.com/u/13311001"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>[转] Java 8 开发的 4 大顶级技巧</a></h3></div><div class="post-content"><blockquote>
<p>本文由 <a href="http://ksria.com/simpread/" target="_blank" rel="noopener">简悦 SimpRead</a> 转码， 原文地址 <a href="http://www.importnew.com/22417.html" target="_blank" rel="noopener">http://www.importnew.com/22417.html</a> 译文出处： <a href="https://www.evget.com/article/2016/8/10/24674.html" target="_blank" rel="noopener">Elyn</a>   原文出处：<a href="https://dzone.com/articles/java-8-top-tips" target="_blank" rel="noopener">Java 8 Top Tips</a></p>
</blockquote>
<p>我使用 Java 8 编码已经有些年头，既用于新的应用程序，也用来迁移现有的应用，感觉是时候写一些我发现的非常有用的 “最佳实践”。我个人并不喜欢“最佳实践” 这个说法，因为它意味着 “一刀切” 的解决方案，而编码不可能是这样的工作方式——我们需要亲自去发现什么样的解决方案才是有效的。但是我发现了一些 Java 8 代码中可以帮助我们的一些选择，让我们一起来看看吧。</p>
<h3 id="1-Optional"><a href="#1-Optional" class="headerlink" title="1.Optional"></a><strong>1.Optional</strong></h3><p>Optional 是一个严重被低估的功能，并且有潜力删除很多困扰我们的 NullPointerExceptions。这在代码边界中（要么是正在使用的 API，要么是正在暴露的 API）特别有用，因为它允许你和你的调用代码来推理所期待的东西。</p>
<p>然而，不加思考和设计就应用 Optional 可能会导致影响大量的类，并可能导致可读性更差。下面是一些关于如何高效使用 Optional 的技巧。</p>
<h4 id="Optional-应该只用于返回类型"><a href="#Optional-应该只用于返回类型" class="headerlink" title="Optional 应该只用于返回类型"></a><strong>Optional 应该只用于返回类型</strong></h4><p>…… 不是参数，也不是字段。幸运的是，IntelliJ IDEA 的让你打开检查来查看是是否遵循这些建议。</p>
<p><img src="http://image.evget.com/images/article/2016/java81.png" alt></p>
<p>Optional 值应在遇到它们的地方中处理。IntelliJ IDEA 的建议会防止代码 Optional 泄漏，所以请记得在你发现 Optional 的地方处理它，迅速采取行动。</p>
<p><img src="http://image.evget.com/images/article/2016/java82.png" alt></p>
<h4 id="不应该简单调用-get"><a href="#不应该简单调用-get" class="headerlink" title="不应该简单调用 get()"></a><strong>不应该简单调用 get()</strong></h4><p>Optional 的功能是表达这个值可能是空的，并让你应对这种情况。因此，在对它做任何事情之前一定要检查是否有一个值。只是简单得调用 get() 而不先检查 isPresent() 在某些时候可能会导致空指针。幸运的是，IntelliJ IDEA 也有检查可以提醒你这一点。</p>
<p><img src="http://image.evget.com/images/article/2016/java83.png" alt></p>
<h4 id="可能有更优雅的方式"><a href="#可能有更优雅的方式" class="headerlink" title="可能有更优雅的方式"></a><strong>可能有更优雅的方式</strong></h4><p>结合了 get() 的 isPresent() 当然会很赞…</p>
<p><img src="http://image.evget.com/images/article/2016/java84.png" alt></p>
<p>…… 但也有更优雅的解决方案。你可以使用 orElse 在万一是空值的情况下给一个替代方案。</p>
<p><img src="http://image.evget.com/images/article/2016/java85.png" alt></p>
<p>…… 或者你可以使用 orElseGet 说明在值为空的情况下调用哪个方法。这似乎与上面的例子相同，但 supplier 方法将只在需要的时候调用，因此，如果这是一种昂贵的方法，那么使用 lambda 会有更佳性能。</p>
<p><img src="http://image.evget.com/images/article/2016/java86.png" alt></p>
<h3 id="2-使用-Lambda-表达式"><a href="#2-使用-Lambda-表达式" class="headerlink" title="2. 使用 Lambda 表达式"></a><strong>2. 使用 Lambda 表达式</strong></h3><p>Lambda 表达式是 Java 8 的主要特点之一。即使你还没有使用 Java 8，你现在可能已经对它们有了基本的了解。它们是用 Java 编程的一种新的方式，并且什么是 “最佳实践” 还不明显。下面是我喜欢遵循的一些指引。</p>
<h4 id="保持简短"><a href="#保持简短" class="headerlink" title="保持简短"></a><strong>保持简短</strong></h4><p>函数式程序员与较长的 lambda 表达式相处会更愉快，但那些淫浸于 Java 多年的人会发现保持 lambda 表达式为区区几行代码更容易。你甚至可能更愿意将其限制到一行代码，并且你可以轻松<a href="http://www.amazon.cn/gp/product/B003BY6PLK/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;tag=importnew-23&amp;linkCode=as2&amp;camp=536&amp;creative=3200&amp;creativeASIN=B003BY6PLK" title="重构" target="_blank" rel="noopener">重构</a>较长的表达式为一个方法。</p>
<p><img src="http://image.evget.com/images/article/2016/java87.png" alt></p>
<p>这些甚至可能会成为方法引用。方法引用一开始会觉得有点陌生，但实际上坚持方法引用是有价值的，因为它们在某些情况下有助于可读性，后面我会讨论到这一点。</p>
<p><img src="http://image.evget.com/images/article/2016/java88.png" alt></p>
<h4 id="明确"><a href="#明确" class="headerlink" title="明确"></a><strong>明确</strong></h4><p>类型信息缺少 lambda 表达式，所以你可能会觉得包含类型信息用于参数会很有用。</p>
<p><img src="http://image.evget.com/images/article/2016/java899.png" alt></p>
<p>正如你所见，这回变得相当笨拙。所以我更喜欢给参数取一个有用的名字。当然，不管你有没有这么做，IntelliJ IDEA 可以让你看到参数得类型信息。</p>
<p><img src="http://image.evget.com/images/article/2016/java89.png" alt></p>
<p>甚至是 lambda 所代表的函数式接口：</p>
<p><img src="http://image.evget.com/images/article/2016/java810.png" alt></p>
<h3 id="3-针对-Lambda-表达式设计"><a href="#3-针对-Lambda-表达式设计" class="headerlink" title="3. 针对 Lambda 表达式设计"></a><strong>3. 针对 Lambda 表达式设计</strong></h3><p>我认为 lambda 表达式有点像泛型——和泛型一起，我们经常使用它们（例如，添加类型信息到 List&lt;&gt;），但最好我们可以设计一种方法或一个具有泛型类型（例如 Person&lt; T&gt;）的类。同样的，当使用类似于 Streams API 的东西时，我们会传递 lambda 表达式，但更好的是创造一个需要 lambda 参数的方法。</p>
<p>但是，如果你发现自己处于这类情况下，下面有一些超棒的技巧。</p>
<h4 id="IntelliJ-IDEA-可以帮你引进函数式参数"><a href="#IntelliJ-IDEA-可以帮你引进函数式参数" class="headerlink" title="IntelliJ IDEA 可以帮你引进函数式参数"></a><strong>IntelliJ IDEA 可以帮你引进函数式参数</strong></h4><p>这让你可以在有人将传递一个 lambda 而非 Object 的地方创建一个参数。此功能的好处是，它表明，现有函数式接口匹配规格说明。</p>
<p><img src="http://image.evget.com/images/article/2016/java811.png" alt></p>
<p>这会导致…</p>
<h4 id="使用现有的函数式接口"><a href="#使用现有的函数式接口" class="headerlink" title="使用现有的函数式接口"></a><strong>使用现有的函数式接口</strong></h4><p>随着开发人员越来越熟悉 Java 8 代码，我们就能知道当使用如 Supplier 和 Consumer 的接口时，会发生什么，以及创建一个本地的 ErrorMessageCreator（举个例子）可能会造成混乱，而且浪费。看看这个函数包了解一下哪些已经是可用的。</p>
<h4 id="添加-FunctionalInterface-到函数式接口"><a href="#添加-FunctionalInterface-到函数式接口" class="headerlink" title="添加 @FunctionalInterface 到函数式接口"></a><strong>添加 @FunctionalInterface 到函数式接口</strong></h4><p>如果你确实需要创建自己的函数式接口，那么就这样用此注释标记。这似乎没有太大的作用，但 IntelliJ IDEA 会告诉你，在你的接口不能匹配用于函数式接口的异常的时候。当你没有指定要覆盖的方法时，它会标志：</p>
<p><img src="http://image.evget.com/images/article/2016/java812.png" alt></p>
<p>当你指定了太多方法的时候，它会标志：</p>
<p><img src="http://image.evget.com/images/article/2016/java813.png" alt></p>
<p>并且如果你应用它到一个类而不是接口时，它会警告你：</p>
<p><img src="http://image.evget.com/images/article/2016/java814.png" alt></p>
<p>lambda 表达式可用于带有一个单一抽象方法的任何接口，但它们不能用于符合相同标准的抽象类。似乎不合逻辑，但就是这样。</p>
<h3 id="4-Stream"><a href="#4-Stream" class="headerlink" title="4.Stream"></a><strong>4.Stream</strong></h3><p>Stream API 是 Java 8 另一个大特点，并且我认为我们还真的不知道这对我们的编码方式会产生多大的改变。下面是我发现的一些有用的东西</p>
<h4 id="排队点操作符"><a href="#排队点操作符" class="headerlink" title="排队点操作符"></a><strong>排队点操作符</strong></h4><p>我个人更喜欢排队我的流操作。当然，你没有必要这样，当我发现这样做对我有帮助：</p>
<ul>
<li>一目了然地看到我有哪些操作</li>
<li>调试更容易（虽然 IntelliJ IDEA 确实提供了对一行中的任意多个 lambda 表达式设置断点的能力，但是拆分到不同的行会变得更简单）</li>
<li>当我测试东西的时候注释操作</li>
<li>轻松插入 peek() 用于调试或测试</li>
</ul>
<p><img src="http://image.evget.com/images/article/2016/java815.png" alt></p>
<p>此外，在我看来，它更整洁。如果我们按照这个模式，在减少代码行数方面我们并没有增加很多。</p>
<p>你可能需要调整格式设置以排列点操作符。</p>
<p><img src="http://image.evget.com/images/article/2016/java816.png" alt></p>
<h4 id="使用方法引用"><a href="#使用方法引用" class="headerlink" title="使用方法引用"></a><strong>使用方法引用</strong></h4><p>是的，确实需要一段时间来适应这个奇怪的语法。但是，如果使用得当，它确实可以增加可读性。请看：</p>
<p><img src="http://image.evget.com/images/article/2016/java817.png" alt></p>
<p>与（相对）新的 Objects 类上的辅助方法相比较：</p>
<p><img src="http://image.evget.com/images/article/2016/java818.png" alt></p>
<p>后者的代码对于哪些值是要保存的更加明确。当 lambda 可以被折叠到方法参考的时候，IntelliJ IDEA 通常会让你知道。</p>
<p><img src="http://image.evget.com/images/article/2016/java819.png" alt></p>
<h4 id="当遍历一个集合时，在可行的情况下使用-Streams-API"><a href="#当遍历一个集合时，在可行的情况下使用-Streams-API" class="headerlink" title="当遍历一个集合时，在可行的情况下使用 Streams API"></a><strong>当遍历一个集合时，在可行的情况下使用 Streams API</strong></h4><p>… 或者新的集合方法，如 forEach。IntelliJ IDEA 给你建议是：</p>
<p><img src="http://image.evget.com/images/article/2016/java820.png" alt></p>
<p>一般使用 Streams API 比循环和 if 语句的组合更加明确。例如：</p>
<p><img src="http://image.evget.com/images/article/2016/java821.png" alt></p>
<p>IntelliJ IDEA 建议这可重构为：</p>
<p><img src="http://image.evget.com/images/article/2016/java822.png" alt></p>
<p>我所做的性能测试表明这种重构令人惊讶——并不总是可预测性能是保持不变，改善还是变得更糟。与往常一样，如果性能在应用程序中是关键，那么在交付一种风格到另一种之前衡量它。</p>
<h4 id="遍历数组时使用循环"><a href="#遍历数组时使用循环" class="headerlink" title="遍历数组时使用循环"></a><strong>遍历数组时使用循环</strong></h4><p>但是，使用 Java 8 并不一定意味着你必须到处使用流和新的集合方法。IntelliJ IDEA 会建议转换成流，但是，这并不意味着你必须回答 “yes”（记得检查是可以抑制或关闭的）。</p>
<p>特别是，遍历原始类型的小型数组几乎肯定会用，以获得更好的性能循环，很可能（至少对于 Java 开发人员是新的流）更具可读性。</p>
<p><img src="http://image.evget.com/images/article/2016/java823.png" alt></p>
<p>与任何技巧一样，规则并不是一成不变的，但你应该决定是尽可能地使用 Streams API，还是依然对一些操作使用循环。总之，要一致。</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a><strong>最后</strong></h3><p>每天都在发现新的东西，并且有时候我的偏好会发生变化——例如，方法引用，我曾经深恶痛绝并且避免在我的代码中使用。现在我很想听听你的秘诀！</p>
<p>本文地址 <a href="https://blog.coder4j.cn/2018/02/26/转-Java-8-开发的-4-大顶级技巧/">https://blog.coder4j.cn/2018/02/26/转-Java-8-开发的-4-大顶级技巧/</a> </p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2018-02-26</span><i class="fa fa-tag"></i><a class="tag" href="/tags/jdk8/" title="jdk8">jdk8 </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,https://blog.coder4j.cn/2018/02/26/转-Java-8-开发的-4-大顶级技巧/,求索之路,[转] Java 8 开发的 4 大顶级技巧,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2018/04/02/转-有没有安全的工作？/" title="[转] 有没有安全的工作？">Post Anterior</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2018/02/26/转-使用-Java8-Optional-的正确姿势/" title="[转] 使用 Java8 Optional 的正确姿势">Próximo post</a></li></ul></div><a id="comments"></a><div id="vcomments" style="margin:0 30px;"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//cdn.jsdelivr.net/gh/xcss/valine@v1.1.7/dist/Valine.min.js?v=undefined"></script><script>var valine = new Valine({
  el:'#vcomments',
  notify:false || false, 
  verify:false|| false, 
  app_id:'8yC4X3BzOzeAMrSi2SrEwbMc-gzGzoHsz',
  app_key:'M6soikk87YmsFLtgwu6vVqed',
  placeholder:'ヾﾉ≧∀≦)o来啊，快活啊!',
  path: window.location.pathname,
  avatar:'wavatar'
})</script></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>